fn rpl(string, search, replace)
    <- str_replace(search, replace, string)

fn sjoin(l, separator=", ")
    return join(l.arr, separator)

fn type(guy)
    <- gettype(guy)

fn uu(l)
    <- sjoin(l, '__')

fn pp(obj, indent=0)
    for k,v in obj
        type = v->gettype()
        if type == "string" or type == "integer" or type == "NULL"
            echo "%s%s: %s\n"->sprintf(str_repeat(" ", indent*2), str(k), str(v))
        elif type == "boolean"
            echo "%s%s: %s\n"->sprintf(str_repeat(" ", indent*2), str(k), if v then "true" else "false")
        elif type == "object"
            echo "%s%s - %s\n"->sprintf(str_repeat(" ", indent*2), k, 
                                        v->get_class())
            pp(v, indent+1)
        elif type == "array"
            echo "%s%s - %s\n"->sprintf(str_repeat(" ", indent*2), k, 
                                        "array")
            pp(v, indent+1)
        else
            type->var_dump()
            throw Exception("Type not implemented: " % type)

fn v(x)
    var_dump(x)

class Snowscript_Visitors_Scope
    extends PHPParser_NodeVisitorAbstract
    fn __construct(ns)
        .ns = ns
        .scopes = [{'names': {}, 'prefix': []}]
        .func = null
        .in_assign = false

    fn name_in_cur_scope(name)
        <- .scopes[-1].names.get(name)

    fn new_name_from_cur_scope(name)
        <- .scopes[-1].names[name].new_name

    fn name_in_prev_scope(name)
        try
            <- .scopes[-2].names.get(name)
        catch IndexError e
            <- False

    fn make_new_name_cur(name)
        if count(.scopes) == 1
            <- [.ns, name]->uu()
        else
            <- [.scopes[-1].prefix->uu(), name]->uu()

    fn make_new_name_prev(name)
        <- [.scopes[-2].prefix->uu(), name]->uu()

    fn add_node_to_cur_scope(node, name, new_name, is_global, global_name)
        if not .scopes[-1].names.get(name)
            .scopes[-1].names[name] = {
                'nodes': [],
                'new_name': null,
                'is_global': null,
                'global_name': global_name,
            }
        .scopes[-1].names[name].is_global = is_global
        .scopes[-1].names[name].nodes.append(node)

    fn rename_nodes(name, new_name, scope_index)
        .scopes[scope_index].names[name].new_name = new_name
        for node in .scopes[scope_index].names[name].nodes
            if node isa PHPParser_Node_Expr_Assign
                node.var.name = new_name
            elif node isa PHPParser_Node_Stmt_Function
                node.name = new_name
            elif node isa PHPParser_Node_Expr_FuncCall
                node.name.parts[0] = new_name
            elif node isa PHPParser_Node_Expr_Variable
                node.name = new_name
            else
                throw Exception("Not supported: " % node->get_class())

    fn rename_nodes_cur_scope(name, new_name)
        .rename_nodes(name, new_name, -1)

    fn rename_nodes_all_scopes(name, new_name)
        for k,scope in .scopes
            if scope.names.get(name)
                .rename_nodes(name, new_name, k)

    fn name_in_prev_is_global(name)
        <- .scopes[-2].names[name].is_global

    fn mark_prev_scope_global(name)
        for scope in .scopes
            try
                scope.names[name].is_global = true
            catch KeyError e
                pass

    fn get_global_name_prev(name)
        <- .scopes[-2].names[name].global_name

    fn create_name(node, name, locked)
        is_global = false
        global_name = .make_new_name_cur(name)
        if .name_in_prev_scope(name)
            if locked
                throw Exception("Cant redefine name from outer scope: " % name)
            is_global = true
            if .name_in_prev_is_global(name)
                new_name = .get_global_name_prev(name)
            else
                new_name = .get_global_name_prev(name)
                .mark_prev_scope_global(name)
                .rename_nodes_all_scopes(name, new_name)
        elif .name_in_cur_scope(name)
            if locked
                throw Exception("Cant redefine name from same scope: " % name)
            new_name = .new_name_from_cur_scope(name)
        else
            if count(.scopes) == 1
                new_name = [.ns, name]->uu()
            else
                new_name = name

        .add_node_to_cur_scope(node, name, new_name, is_global, global_name)
        .rename_nodes_cur_scope(name, new_name)

    fn enterNode(PHPParser_Node node)
        if node isa PHPParser_Node_Expr_Assign
            .create_name(node, node.var.name, false)
            .in_assign = true
        elif node isa PHPParser_Node_Stmt_Function
            .create_name(node, node.name, true)
            .scopes.append(.scopes[-1].copy())
            .scopes[-1].prefix.append(node.name)
        elif node isa PHPParser_Node_Expr_Variable
            if not .in_assign
                .create_name(node, node.name, false)
        elif node isa PHPParser_Node_Expr_FuncCall
            if count(node.name.parts) == 1
                .create_name(node, node.name.parts[0], false)
                node.as_variable = true

    fn leaveNode(PHPParser_Node node)
        if node isa PHPParser_Node_Stmt_Imports
            <- false
        if node isa PHPParser_Node_Stmt_Function
            .scopes.pop()
        if node isa PHPParser_Node_Expr_Assign
            .in_assign = false

    fn afterTraverse(array nodes)
        <- nodes

    fn add_imports(node)
        paths = []
        for import_path in node.import_paths
            paths []= import_path.name
        prefix = paths->uu()

        for imp in node.imports
            .scopes[0]['imports'][imp.name] = "{prefix}__{imp.name}"